{"ast":null,"code":"'use strict';\n\nconst http = require('http');\n\nconst https = require('https');\n\nconst {\n  HttpClient,\n  HttpClientResponse\n} = require('./HttpClient');\n\nconst defaultHttpAgent = new http.Agent({\n  keepAlive: true\n});\nconst defaultHttpsAgent = new https.Agent({\n  keepAlive: true\n});\n/**\n * HTTP client which uses the Node `http` and `https` packages to issue\n * requests.`\n */\n\nclass NodeHttpClient extends HttpClient {\n  constructor(agent) {\n    super();\n    this._agent = agent;\n  }\n  /** @override. */\n\n\n  getClientName() {\n    return 'node';\n  }\n\n  makeRequest(host, port, path, method, headers, requestData, protocol, timeout) {\n    const isInsecureConnection = protocol === 'http';\n    let agent = this._agent;\n\n    if (!agent) {\n      agent = isInsecureConnection ? defaultHttpAgent : defaultHttpsAgent;\n    }\n\n    const requestPromise = new Promise((resolve, reject) => {\n      const req = (isInsecureConnection ? http : https).request({\n        host: host,\n        port: port,\n        path,\n        method,\n        agent,\n        headers,\n        ciphers: 'DEFAULT:!aNULL:!eNULL:!LOW:!EXPORT:!SSLv2:!MD5'\n      });\n      req.setTimeout(timeout, () => {\n        req.destroy(HttpClient.makeTimeoutError());\n      });\n      req.on('response', res => {\n        resolve(new NodeHttpClientResponse(res));\n      });\n      req.on('error', error => {\n        reject(error);\n      });\n      req.once('socket', socket => {\n        if (socket.connecting) {\n          socket.once(isInsecureConnection ? 'connect' : 'secureConnect', () => {\n            // Send payload; we're safe:\n            req.write(requestData);\n            req.end();\n          });\n        } else {\n          // we're already connected\n          req.write(requestData);\n          req.end();\n        }\n      });\n    });\n    return requestPromise;\n  }\n\n}\n\nclass NodeHttpClientResponse extends HttpClientResponse {\n  constructor(res) {\n    super(res.statusCode, res.headers || {});\n    this._res = res;\n  }\n\n  getRawResponse() {\n    return this._res;\n  }\n\n  toStream(streamCompleteCallback) {\n    // The raw response is itself the stream, so we just return that. To be\n    // backwards comaptible, we should invoke the streamCompleteCallback only\n    // once the stream has been fully consumed.\n    this._res.once('end', () => streamCompleteCallback());\n\n    return this._res;\n  }\n\n  toJSON() {\n    return new Promise((resolve, reject) => {\n      let response = '';\n\n      this._res.setEncoding('utf8');\n\n      this._res.on('data', chunk => {\n        response += chunk;\n      });\n\n      this._res.once('end', () => {\n        try {\n          resolve(JSON.parse(response));\n        } catch (e) {\n          reject(e);\n        }\n      });\n    });\n  }\n\n}\n\nmodule.exports = {\n  NodeHttpClient,\n  NodeHttpClientResponse\n};","map":{"version":3,"sources":["/Volumes/Time Machine Backups/Art/my-art/node_modules/stripe/lib/net/NodeHttpClient.js"],"names":["http","require","https","HttpClient","HttpClientResponse","defaultHttpAgent","Agent","keepAlive","defaultHttpsAgent","NodeHttpClient","constructor","agent","_agent","getClientName","makeRequest","host","port","path","method","headers","requestData","protocol","timeout","isInsecureConnection","requestPromise","Promise","resolve","reject","req","request","ciphers","setTimeout","destroy","makeTimeoutError","on","res","NodeHttpClientResponse","error","once","socket","connecting","write","end","statusCode","_res","getRawResponse","toStream","streamCompleteCallback","toJSON","response","setEncoding","chunk","JSON","parse","e","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst http = require('http');\nconst https = require('https');\n\nconst {HttpClient, HttpClientResponse} = require('./HttpClient');\n\nconst defaultHttpAgent = new http.Agent({keepAlive: true});\nconst defaultHttpsAgent = new https.Agent({keepAlive: true});\n\n/**\n * HTTP client which uses the Node `http` and `https` packages to issue\n * requests.`\n */\nclass NodeHttpClient extends HttpClient {\n  constructor(agent) {\n    super();\n    this._agent = agent;\n  }\n\n  /** @override. */\n  getClientName() {\n    return 'node';\n  }\n\n  makeRequest(\n    host,\n    port,\n    path,\n    method,\n    headers,\n    requestData,\n    protocol,\n    timeout\n  ) {\n    const isInsecureConnection = protocol === 'http';\n\n    let agent = this._agent;\n    if (!agent) {\n      agent = isInsecureConnection ? defaultHttpAgent : defaultHttpsAgent;\n    }\n\n    const requestPromise = new Promise((resolve, reject) => {\n      const req = (isInsecureConnection ? http : https).request({\n        host: host,\n        port: port,\n        path,\n        method,\n        agent,\n        headers,\n        ciphers: 'DEFAULT:!aNULL:!eNULL:!LOW:!EXPORT:!SSLv2:!MD5',\n      });\n\n      req.setTimeout(timeout, () => {\n        req.destroy(HttpClient.makeTimeoutError());\n      });\n\n      req.on('response', (res) => {\n        resolve(new NodeHttpClientResponse(res));\n      });\n\n      req.on('error', (error) => {\n        reject(error);\n      });\n\n      req.once('socket', (socket) => {\n        if (socket.connecting) {\n          socket.once(\n            isInsecureConnection ? 'connect' : 'secureConnect',\n            () => {\n              // Send payload; we're safe:\n              req.write(requestData);\n              req.end();\n            }\n          );\n        } else {\n          // we're already connected\n          req.write(requestData);\n          req.end();\n        }\n      });\n    });\n\n    return requestPromise;\n  }\n}\n\nclass NodeHttpClientResponse extends HttpClientResponse {\n  constructor(res) {\n    super(res.statusCode, res.headers || {});\n    this._res = res;\n  }\n\n  getRawResponse() {\n    return this._res;\n  }\n\n  toStream(streamCompleteCallback) {\n    // The raw response is itself the stream, so we just return that. To be\n    // backwards comaptible, we should invoke the streamCompleteCallback only\n    // once the stream has been fully consumed.\n    this._res.once('end', () => streamCompleteCallback());\n    return this._res;\n  }\n\n  toJSON() {\n    return new Promise((resolve, reject) => {\n      let response = '';\n\n      this._res.setEncoding('utf8');\n      this._res.on('data', (chunk) => {\n        response += chunk;\n      });\n      this._res.once('end', () => {\n        try {\n          resolve(JSON.parse(response));\n        } catch (e) {\n          reject(e);\n        }\n      });\n    });\n  }\n}\n\nmodule.exports = {NodeHttpClient, NodeHttpClientResponse};\n"]},"metadata":{},"sourceType":"script"}