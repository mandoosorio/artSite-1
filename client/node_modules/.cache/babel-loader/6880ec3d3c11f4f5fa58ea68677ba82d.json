{"ast":null,"code":"'use strict';\n\nconst utils = require('./utils');\n\nfunction getRequestOpts(self, requestArgs, spec, overrideData) {\n  // Extract spec values with defaults.\n  const requestMethod = (spec.method || 'GET').toUpperCase();\n  const urlParams = spec.urlParams || [];\n\n  const encode = spec.encode || (data => data);\n\n  const isUsingFullPath = !!spec.fullPath;\n  const commandPath = utils.makeURLInterpolator(isUsingFullPath ? spec.fullPath : spec.path || ''); // When using fullPath, we ignore the resource path as it should already be\n  // fully qualified.\n\n  const path = isUsingFullPath ? spec.fullPath : self.createResourcePathWithSymbols(spec.path); // Don't mutate args externally.\n\n  const args = [].slice.call(requestArgs); // Generate and validate url params.\n\n  const urlData = urlParams.reduce((urlData, param) => {\n    const arg = args.shift();\n\n    if (typeof arg !== 'string') {\n      throw new Error(`Stripe: Argument \"${param}\" must be a string, but got: ${arg} (on API request to \\`${requestMethod} ${path}\\`)`);\n    }\n\n    urlData[param] = arg;\n    return urlData;\n  }, {}); // Pull request data and options (headers, auth) from args.\n\n  const dataFromArgs = utils.getDataFromArgs(args);\n  const data = encode(Object.assign({}, dataFromArgs, overrideData));\n  const options = utils.getOptionsFromArgs(args);\n  const host = options.host || spec.host;\n  const streaming = !!spec.streaming; // Validate that there are no more args.\n\n  if (args.filter(x => x != null).length) {\n    throw new Error(`Stripe: Unknown arguments (${args}). Did you mean to pass an options object? See https://github.com/stripe/stripe-node/wiki/Passing-Options. (on API request to ${requestMethod} \\`${path}\\`)`);\n  } // When using full path, we can just invoke the URL interpolator directly\n  // as we don't need to use the resource to create a full path.\n\n\n  const requestPath = isUsingFullPath ? commandPath(urlData) : self.createFullPath(commandPath, urlData);\n  const headers = Object.assign(options.headers, spec.headers);\n\n  if (spec.validator) {\n    spec.validator(data, {\n      headers\n    });\n  }\n\n  const dataInQuery = spec.method === 'GET' || spec.method === 'DELETE';\n  const bodyData = dataInQuery ? {} : data;\n  const queryData = dataInQuery ? data : {};\n  return {\n    requestMethod,\n    requestPath,\n    bodyData,\n    queryData,\n    auth: options.auth,\n    headers,\n    host,\n    streaming,\n    settings: options.settings\n  };\n}\n\nfunction makeRequest(self, requestArgs, spec, overrideData) {\n  return new Promise((resolve, reject) => {\n    let opts;\n\n    try {\n      opts = getRequestOpts(self, requestArgs, spec, overrideData);\n    } catch (err) {\n      reject(err);\n      return;\n    }\n\n    function requestCallback(err, response) {\n      if (err) {\n        reject(err);\n      } else {\n        resolve(spec.transformResponseData ? spec.transformResponseData(response) : response);\n      }\n    }\n\n    const emptyQuery = Object.keys(opts.queryData).length === 0;\n    const path = [opts.requestPath, emptyQuery ? '' : '?', utils.stringifyRequestData(opts.queryData)].join('');\n    const {\n      headers,\n      settings\n    } = opts;\n\n    self._request(opts.requestMethod, opts.host, path, opts.bodyData, opts.auth, {\n      headers,\n      settings,\n      streaming: opts.streaming\n    }, requestCallback);\n  });\n}\n\nmodule.exports = makeRequest;","map":{"version":3,"sources":["/Volumes/Time Machine Backups/Art/my-art/node_modules/stripe/lib/makeRequest.js"],"names":["utils","require","getRequestOpts","self","requestArgs","spec","overrideData","requestMethod","method","toUpperCase","urlParams","encode","data","isUsingFullPath","fullPath","commandPath","makeURLInterpolator","path","createResourcePathWithSymbols","args","slice","call","urlData","reduce","param","arg","shift","Error","dataFromArgs","getDataFromArgs","Object","assign","options","getOptionsFromArgs","host","streaming","filter","x","length","requestPath","createFullPath","headers","validator","dataInQuery","bodyData","queryData","auth","settings","makeRequest","Promise","resolve","reject","opts","err","requestCallback","response","transformResponseData","emptyQuery","keys","stringifyRequestData","join","_request","module","exports"],"mappings":"AAAA;;AAEA,MAAMA,KAAK,GAAGC,OAAO,CAAC,SAAD,CAArB;;AAEA,SAASC,cAAT,CAAwBC,IAAxB,EAA8BC,WAA9B,EAA2CC,IAA3C,EAAiDC,YAAjD,EAA+D;AAC7D;AACA,QAAMC,aAAa,GAAG,CAACF,IAAI,CAACG,MAAL,IAAe,KAAhB,EAAuBC,WAAvB,EAAtB;AACA,QAAMC,SAAS,GAAGL,IAAI,CAACK,SAAL,IAAkB,EAApC;;AACA,QAAMC,MAAM,GAAGN,IAAI,CAACM,MAAL,KAAiBC,IAAD,IAAUA,IAA1B,CAAf;;AAEA,QAAMC,eAAe,GAAG,CAAC,CAACR,IAAI,CAACS,QAA/B;AACA,QAAMC,WAAW,GAAGf,KAAK,CAACgB,mBAAN,CAClBH,eAAe,GAAGR,IAAI,CAACS,QAAR,GAAmBT,IAAI,CAACY,IAAL,IAAa,EAD7B,CAApB,CAP6D,CAW7D;AACA;;AACA,QAAMA,IAAI,GAAGJ,eAAe,GACxBR,IAAI,CAACS,QADmB,GAExBX,IAAI,CAACe,6BAAL,CAAmCb,IAAI,CAACY,IAAxC,CAFJ,CAb6D,CAiB7D;;AACA,QAAME,IAAI,GAAG,GAAGC,KAAH,CAASC,IAAT,CAAcjB,WAAd,CAAb,CAlB6D,CAoB7D;;AACA,QAAMkB,OAAO,GAAGZ,SAAS,CAACa,MAAV,CAAiB,CAACD,OAAD,EAAUE,KAAV,KAAoB;AACnD,UAAMC,GAAG,GAAGN,IAAI,CAACO,KAAL,EAAZ;;AACA,QAAI,OAAOD,GAAP,KAAe,QAAnB,EAA6B;AAC3B,YAAM,IAAIE,KAAJ,CACH,qBAAoBH,KAAM,gCAA+BC,GAAI,yBAAwBlB,aAAc,IAAGU,IAAK,KADxG,CAAN;AAGD;;AAEDK,IAAAA,OAAO,CAACE,KAAD,CAAP,GAAiBC,GAAjB;AACA,WAAOH,OAAP;AACD,GAVe,EAUb,EAVa,CAAhB,CArB6D,CAiC7D;;AACA,QAAMM,YAAY,GAAG5B,KAAK,CAAC6B,eAAN,CAAsBV,IAAtB,CAArB;AACA,QAAMP,IAAI,GAAGD,MAAM,CAACmB,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBH,YAAlB,EAAgCtB,YAAhC,CAAD,CAAnB;AACA,QAAM0B,OAAO,GAAGhC,KAAK,CAACiC,kBAAN,CAAyBd,IAAzB,CAAhB;AACA,QAAMe,IAAI,GAAGF,OAAO,CAACE,IAAR,IAAgB7B,IAAI,CAAC6B,IAAlC;AACA,QAAMC,SAAS,GAAG,CAAC,CAAC9B,IAAI,CAAC8B,SAAzB,CAtC6D,CAuC7D;;AACA,MAAIhB,IAAI,CAACiB,MAAL,CAAaC,CAAD,IAAOA,CAAC,IAAI,IAAxB,EAA8BC,MAAlC,EAA0C;AACxC,UAAM,IAAIX,KAAJ,CACH,8BAA6BR,IAAK,iIAAgIZ,aAAc,MAAKU,IAAK,KADvL,CAAN;AAGD,GA5C4D,CA8C7D;AACA;;;AACA,QAAMsB,WAAW,GAAG1B,eAAe,GAC/BE,WAAW,CAACO,OAAD,CADoB,GAE/BnB,IAAI,CAACqC,cAAL,CAAoBzB,WAApB,EAAiCO,OAAjC,CAFJ;AAGA,QAAMmB,OAAO,GAAGX,MAAM,CAACC,MAAP,CAAcC,OAAO,CAACS,OAAtB,EAA+BpC,IAAI,CAACoC,OAApC,CAAhB;;AAEA,MAAIpC,IAAI,CAACqC,SAAT,EAAoB;AAClBrC,IAAAA,IAAI,CAACqC,SAAL,CAAe9B,IAAf,EAAqB;AAAC6B,MAAAA;AAAD,KAArB;AACD;;AAED,QAAME,WAAW,GAAGtC,IAAI,CAACG,MAAL,KAAgB,KAAhB,IAAyBH,IAAI,CAACG,MAAL,KAAgB,QAA7D;AACA,QAAMoC,QAAQ,GAAGD,WAAW,GAAG,EAAH,GAAQ/B,IAApC;AACA,QAAMiC,SAAS,GAAGF,WAAW,GAAG/B,IAAH,GAAU,EAAvC;AAEA,SAAO;AACLL,IAAAA,aADK;AAELgC,IAAAA,WAFK;AAGLK,IAAAA,QAHK;AAILC,IAAAA,SAJK;AAKLC,IAAAA,IAAI,EAAEd,OAAO,CAACc,IALT;AAMLL,IAAAA,OANK;AAOLP,IAAAA,IAPK;AAQLC,IAAAA,SARK;AASLY,IAAAA,QAAQ,EAAEf,OAAO,CAACe;AATb,GAAP;AAWD;;AAED,SAASC,WAAT,CAAqB7C,IAArB,EAA2BC,WAA3B,EAAwCC,IAAxC,EAA8CC,YAA9C,EAA4D;AAC1D,SAAO,IAAI2C,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACtC,QAAIC,IAAJ;;AACA,QAAI;AACFA,MAAAA,IAAI,GAAGlD,cAAc,CAACC,IAAD,EAAOC,WAAP,EAAoBC,IAApB,EAA0BC,YAA1B,CAArB;AACD,KAFD,CAEE,OAAO+C,GAAP,EAAY;AACZF,MAAAA,MAAM,CAACE,GAAD,CAAN;AACA;AACD;;AAED,aAASC,eAAT,CAAyBD,GAAzB,EAA8BE,QAA9B,EAAwC;AACtC,UAAIF,GAAJ,EAAS;AACPF,QAAAA,MAAM,CAACE,GAAD,CAAN;AACD,OAFD,MAEO;AACLH,QAAAA,OAAO,CACL7C,IAAI,CAACmD,qBAAL,GACInD,IAAI,CAACmD,qBAAL,CAA2BD,QAA3B,CADJ,GAEIA,QAHC,CAAP;AAKD;AACF;;AAED,UAAME,UAAU,GAAG3B,MAAM,CAAC4B,IAAP,CAAYN,IAAI,CAACP,SAAjB,EAA4BP,MAA5B,KAAuC,CAA1D;AACA,UAAMrB,IAAI,GAAG,CACXmC,IAAI,CAACb,WADM,EAEXkB,UAAU,GAAG,EAAH,GAAQ,GAFP,EAGXzD,KAAK,CAAC2D,oBAAN,CAA2BP,IAAI,CAACP,SAAhC,CAHW,EAIXe,IAJW,CAIN,EAJM,CAAb;AAMA,UAAM;AAACnB,MAAAA,OAAD;AAAUM,MAAAA;AAAV,QAAsBK,IAA5B;;AAEAjD,IAAAA,IAAI,CAAC0D,QAAL,CACET,IAAI,CAAC7C,aADP,EAEE6C,IAAI,CAAClB,IAFP,EAGEjB,IAHF,EAIEmC,IAAI,CAACR,QAJP,EAKEQ,IAAI,CAACN,IALP,EAME;AAACL,MAAAA,OAAD;AAAUM,MAAAA,QAAV;AAAoBZ,MAAAA,SAAS,EAAEiB,IAAI,CAACjB;AAApC,KANF,EAOEmB,eAPF;AASD,GAvCM,CAAP;AAwCD;;AAEDQ,MAAM,CAACC,OAAP,GAAiBf,WAAjB","sourcesContent":["'use strict';\n\nconst utils = require('./utils');\n\nfunction getRequestOpts(self, requestArgs, spec, overrideData) {\n  // Extract spec values with defaults.\n  const requestMethod = (spec.method || 'GET').toUpperCase();\n  const urlParams = spec.urlParams || [];\n  const encode = spec.encode || ((data) => data);\n\n  const isUsingFullPath = !!spec.fullPath;\n  const commandPath = utils.makeURLInterpolator(\n    isUsingFullPath ? spec.fullPath : spec.path || ''\n  );\n\n  // When using fullPath, we ignore the resource path as it should already be\n  // fully qualified.\n  const path = isUsingFullPath\n    ? spec.fullPath\n    : self.createResourcePathWithSymbols(spec.path);\n\n  // Don't mutate args externally.\n  const args = [].slice.call(requestArgs);\n\n  // Generate and validate url params.\n  const urlData = urlParams.reduce((urlData, param) => {\n    const arg = args.shift();\n    if (typeof arg !== 'string') {\n      throw new Error(\n        `Stripe: Argument \"${param}\" must be a string, but got: ${arg} (on API request to \\`${requestMethod} ${path}\\`)`\n      );\n    }\n\n    urlData[param] = arg;\n    return urlData;\n  }, {});\n\n  // Pull request data and options (headers, auth) from args.\n  const dataFromArgs = utils.getDataFromArgs(args);\n  const data = encode(Object.assign({}, dataFromArgs, overrideData));\n  const options = utils.getOptionsFromArgs(args);\n  const host = options.host || spec.host;\n  const streaming = !!spec.streaming;\n  // Validate that there are no more args.\n  if (args.filter((x) => x != null).length) {\n    throw new Error(\n      `Stripe: Unknown arguments (${args}). Did you mean to pass an options object? See https://github.com/stripe/stripe-node/wiki/Passing-Options. (on API request to ${requestMethod} \\`${path}\\`)`\n    );\n  }\n\n  // When using full path, we can just invoke the URL interpolator directly\n  // as we don't need to use the resource to create a full path.\n  const requestPath = isUsingFullPath\n    ? commandPath(urlData)\n    : self.createFullPath(commandPath, urlData);\n  const headers = Object.assign(options.headers, spec.headers);\n\n  if (spec.validator) {\n    spec.validator(data, {headers});\n  }\n\n  const dataInQuery = spec.method === 'GET' || spec.method === 'DELETE';\n  const bodyData = dataInQuery ? {} : data;\n  const queryData = dataInQuery ? data : {};\n\n  return {\n    requestMethod,\n    requestPath,\n    bodyData,\n    queryData,\n    auth: options.auth,\n    headers,\n    host,\n    streaming,\n    settings: options.settings,\n  };\n}\n\nfunction makeRequest(self, requestArgs, spec, overrideData) {\n  return new Promise((resolve, reject) => {\n    let opts;\n    try {\n      opts = getRequestOpts(self, requestArgs, spec, overrideData);\n    } catch (err) {\n      reject(err);\n      return;\n    }\n\n    function requestCallback(err, response) {\n      if (err) {\n        reject(err);\n      } else {\n        resolve(\n          spec.transformResponseData\n            ? spec.transformResponseData(response)\n            : response\n        );\n      }\n    }\n\n    const emptyQuery = Object.keys(opts.queryData).length === 0;\n    const path = [\n      opts.requestPath,\n      emptyQuery ? '' : '?',\n      utils.stringifyRequestData(opts.queryData),\n    ].join('');\n\n    const {headers, settings} = opts;\n\n    self._request(\n      opts.requestMethod,\n      opts.host,\n      path,\n      opts.bodyData,\n      opts.auth,\n      {headers, settings, streaming: opts.streaming},\n      requestCallback\n    );\n  });\n}\n\nmodule.exports = makeRequest;\n"]},"metadata":{},"sourceType":"script"}